struct Agent {
    pos : vec2f,
    rot : f32,
    pad : f32,
}

// boid data
@group(0) @binding(0) var<storage, read_write> agents: array<Agent>;

// new version of webgpu supports read_write storage textures
// https://github.com/gfx-rs/wgpu/issues/2735
@group(0) @binding(1) var trail_texture_read: texture_2d<f32>;
@group(0) @binding(2) var trail_texture_write: texture_storage_2d<rgba8unorm, write>;
@group(0) @binding(3) var<uniform> dt : f32;

// @group(0) @binding(1) var<storage, read_write> boids_next : array<Boid>;
// @group(0) @binding(0) var<storage, read> boids_curr : array<Boid>;
// @group(0) @binding(2) var<uniform> num_boids : u32;
// // simulation parameters
// @group(0) @binding(12) var<uniform> volume: f32;
// @group(0) @binding(13) var<uniform> volume_factor: f32;

fn deg2rad(deg: f32) -> f32 { return deg * 3.14159 / 180.0; }
fn rand(co: f32) -> f32 { return fract(sin(co*(91.3458)) * 47453.5453); }
fn rand2(co: vec2f) -> f32 { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
fn rand3(co: vec3f) -> f32 { return rand2(co.xy+rand(co.z)); }

fn sense(pos_pixel: vec2f, rot: f32, delta_angle: f32, dim: vec2i) -> f32 {

    // these params are in pixels
    let sensor_offset = 4.0; // TODO make param
    let sensor_size: i32 = 4; // TODO make param

    var sensor_dir = vec2f(cos(rot + delta_angle), sin(rot + delta_angle));
    var sensor_pos = pos_pixel + sensor_dir * sensor_offset;
    var sum = 0.0;

    for (var dx = -sensor_size; dx <= sensor_size; dx++) {
        for (var dy = -sensor_size; dy <= sensor_size; dy++) {
            let coord = vec2i(sensor_pos + vec2f(f32(dx), f32(dy)));
            // can improve sampling with linear filtering
            if (coord.x >= 0 && coord.x < dim.x && coord.y >= 0 && coord.y < dim.y) {
                sum += textureLoad(trail_texture_read, coord, 0).r; // NOTE: assuming every channel holds same value
            }
        }
    }

    return sum;
}

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    // PARAMS
    let speed_pixels = 60.0; 
    let sense_angle_deg = 10.0;  
    let turn_speed_deg = 1000.0;
    
    let index = GlobalInvocationID.x;
    if (index >= arrayLength(&agents)) {
        return;
    }

    var pos = agents[index].pos;
    var rot = agents[index].rot;
    let random = rand3(vec3(pos, f32(index)));

    let dim = vec2i(textureDimensions(trail_texture_read));
    var pos_pixel = pos * vec2f(dim);

    // steer
    let left = sense(pos_pixel, rot, deg2rad(sense_angle_deg), dim);
    let forward = sense(pos_pixel, rot, 0.0, dim);
    let right = sense(pos_pixel, rot, deg2rad(-sense_angle_deg), dim);
    // TODO try picking based on a pdf here
    if (forward > left && forward > right) {
        // do nothing
    } else if (forward < left && forward < right) {
        // turn randomly
        rot += 2.0 * (random - 0.5) * deg2rad(turn_speed_deg) * dt;
    } else if (right > left) {
        rot -= random * deg2rad(turn_speed_deg) * dt;
    } else if (left > right) {
        rot += random * deg2rad(turn_speed_deg) * dt;
    }

    pos_pixel += vec2f(cos(rot), sin(rot)) * speed_pixels * dt;
    pos = pos_pixel / vec2f(dim);

    // boundaries
    if (pos.x < 0 || pos.x > 1 || pos.y < 0 || pos.y > 1) {
        pos = clamp(pos, vec2f(0.0), vec2f(1.0));
        rot = random * 2.0 * 3.14159;
    }

    // write back
    agents[index].pos = pos;
    agents[index].rot = rot;

    // dump to texture
    var tex_coords = vec2u(pos * vec2f(textureDimensions(trail_texture_write)));
    textureStore(trail_texture_write, tex_coords, vec4f(1));
}